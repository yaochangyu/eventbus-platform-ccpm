---
name: Callback機制實作 (Red→Green)
status: open
created: 2025-09-13T13:20:32Z
updated: 2025-09-13T13:20:32Z
github: [Will be updated when synced to GitHub]
depends_on: [006]  # 需要API控制器完成
parallel: true   # 可與效能測試並行
conflicts_with: []
---

# Task: Callback機制實作 (Red→Green)

## Description

實作 HTTP Callback 機制，讓所有與 Callback 相關的 Gherkin 測試場景從**紅燈轉為綠燈**。這是 BDD Red→Green 階段的最後一步，完成後所有功能測試都應該通過。

## BDD Context
**目標**: 讓以下 Callback 測試場景通過
- TaskExecution.feature: 成功執行任務並呼叫 Callback
- TaskExecution.feature: Callback API 呼叫失敗處理
- 任務狀態正確更新 (Processing → Completed/Failed)
- 封存機制觸發 (Completed 任務自動搬移)

## Acceptance Criteria
- [ ] 實作 ICallbackService 介面和實作類別
- [ ] HttpClient 與 Polly 重試策略整合
- [ ] 更新 TaskService.ExecuteTaskAsync 包含 Callback 邏輯
- [ ] 實作背景服務處理 Callback 佇列 (選擇性)
- [ ] **所有 Callback 相關的 BDD 測試通過**
- [ ] 錯誤處理和重試機制正確運作
- [ ] 同步和非同步 Callback 都支援

## Technical Details

### ICallbackService 介面
```csharp
// Services/ICallbackService.cs
public interface ICallbackService
{
    Task<Result<CallbackResult>> ExecuteCallbackAsync(string callbackUrl, object payload, CancellationToken cancellationToken = default);
    Task<Result<CallbackResult>> ExecuteCallbackWithRetryAsync(string callbackUrl, object payload, int maxRetries = 3);
}

// Models/CallbackResult.cs
public record CallbackResult
{
    public bool IsSuccess { get; init; }
    public int StatusCode { get; init; }
    public string? ResponseBody { get; init; }
    public string? ErrorMessage { get; init; }
    public DateTime ExecutedAt { get; init; }
    public TimeSpan Duration { get; init; }
}
```

### CallbackService 實作
```csharp
// Services/CallbackService.cs
public class CallbackService : ICallbackService
{
    private readonly HttpClient _httpClient;
    private readonly ILogger<CallbackService> _logger;

    public CallbackService(HttpClient httpClient, ILogger<CallbackService> logger)
    {
        _httpClient = httpClient;
        _logger = logger;
    }

    public async Task<Result<CallbackResult>> ExecuteCallbackAsync(string callbackUrl, object payload, CancellationToken cancellationToken = default)
    {
        var stopwatch = Stopwatch.StartNew();

        try
        {
            _logger.LogInformation("Executing callback to {CallbackUrl}", callbackUrl);

            var json = JsonSerializer.Serialize(payload);
            var content = new StringContent(json, Encoding.UTF8, "application/json");

            var response = await _httpClient.PostAsync(callbackUrl, content, cancellationToken);
            var responseBody = await response.Content.ReadAsStringAsync(cancellationToken);

            stopwatch.Stop();

            var result = new CallbackResult
            {
                IsSuccess = response.IsSuccessStatusCode,
                StatusCode = (int)response.StatusCode,
                ResponseBody = responseBody,
                ExecutedAt = DateTime.UtcNow,
                Duration = stopwatch.Elapsed
            };

            if (response.IsSuccessStatusCode)
            {
                _logger.LogInformation("Callback executed successfully. Status: {StatusCode}, Duration: {Duration}ms",
                    result.StatusCode, result.Duration.TotalMilliseconds);
            }
            else
            {
                _logger.LogWarning("Callback failed. Status: {StatusCode}, Response: {Response}",
                    result.StatusCode, responseBody);
            }

            return Result<CallbackResult>.Success(result);
        }
        catch (TaskCanceledException ex) when (ex.InnerException is TimeoutException)
        {
            stopwatch.Stop();
            _logger.LogError("Callback timed out after {Duration}ms", stopwatch.Elapsed.TotalMilliseconds);

            return Result<CallbackResult>.Failure("Callback request timed out");
        }
        catch (HttpRequestException ex)
        {
            stopwatch.Stop();
            _logger.LogError(ex, "HTTP error during callback execution");

            return Result<CallbackResult>.Failure($"HTTP error: {ex.Message}");
        }
        catch (Exception ex)
        {
            stopwatch.Stop();
            _logger.LogError(ex, "Unexpected error during callback execution");

            return Result<CallbackResult>.Failure($"Unexpected error: {ex.Message}");
        }
    }

    public async Task<Result<CallbackResult>> ExecuteCallbackWithRetryAsync(string callbackUrl, object payload, int maxRetries = 3)
    {
        CallbackResult? lastResult = null;

        for (int attempt = 1; attempt <= maxRetries; attempt++)
        {
            var result = await ExecuteCallbackAsync(callbackUrl, payload);

            if (result.IsSuccess && result.Value!.IsSuccess)
                return result;

            lastResult = result.Value;

            if (attempt < maxRetries)
            {
                var delay = TimeSpan.FromSeconds(Math.Pow(2, attempt)); // 指數退避
                _logger.LogWarning("Callback attempt {Attempt} failed, retrying in {Delay}s", attempt, delay.TotalSeconds);
                await Task.Delay(delay);
            }
        }

        return Result<CallbackResult>.Failure($"Callback failed after {maxRetries} attempts. Last error: {lastResult?.ErrorMessage}");
    }
}
```

### 更新 TaskService
```csharp
// Services/TaskService.cs - 更新 ExecuteTaskAsync 方法
public async Task<Result<TaskExecutionResponse>> ExecuteTaskAsync(Guid taskId)
{
    // 1. 取得任務並檢查狀態
    var getResult = await _repository.GetByIdAsync(taskId);
    if (!getResult.IsSuccess || getResult.Value == null)
        return Result<TaskExecutionResponse>.Failure("Task not found");

    var task = getResult.Value;
    if (task.Status != TaskStatus.Pending)
        return Result<TaskExecutionResponse>.Failure($"Task cannot be executed. Current status: {task.Status}");

    // 2. 更新狀態為 Processing
    task.Status = TaskStatus.Processing;
    task.UpdatedAt = DateTime.UtcNow;
    await _repository.UpdateAsync(task);

    // 3. 執行 Callback
    var callbackPayload = new
    {
        TaskId = task.Id,
        TaskName = task.Name,
        Payload = task.Payload,
        ExecutedAt = DateTime.UtcNow
    };

    var callbackResult = await _callbackService.ExecuteCallbackWithRetryAsync(task.CallbackUrl, callbackPayload);

    // 4. 根據 Callback 結果更新任務狀態
    if (callbackResult.IsSuccess && callbackResult.Value!.IsSuccess)
    {
        task.Status = TaskStatus.Completed;
        task.CallbackResult = callbackResult.Value.ResponseBody;
    }
    else
    {
        task.Status = TaskStatus.Failed;
        task.CallbackResult = callbackResult.ErrorMessage;
    }

    task.ExecutedAt = DateTime.UtcNow;
    task.UpdatedAt = DateTime.UtcNow;
    await _repository.UpdateAsync(task); // 這裡會觸發自動封存

    return Result<TaskExecutionResponse>.Success(new TaskExecutionResponse
    {
        TaskId = task.Id,
        Status = task.Status,
        ExecutedAt = task.ExecutedAt.Value,
        CallbackResult = task.CallbackResult
    });
}
```

### HttpClient 配置 (含 Polly)
```csharp
// Program.cs
builder.Services.AddHttpClient<ICallbackService, CallbackService>(client =>
{
    client.Timeout = TimeSpan.FromSeconds(30);
    client.DefaultRequestHeaders.Add("User-Agent", "TaskManagement-Service/1.0");
})
.AddPolicyHandler(GetRetryPolicy())
.AddPolicyHandler(GetTimeoutPolicy());

static IAsyncPolicy<HttpResponseMessage> GetRetryPolicy()
{
    return Policy
        .HandleResult<HttpResponseMessage>(r => !r.IsSuccessStatusCode)
        .Or<HttpRequestException>()
        .WaitAndRetryAsync(
            retryCount: 3,
            sleepDurationProvider: retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)),
            onRetry: (outcome, duration, retryCount, context) =>
            {
                Console.WriteLine($"Retry {retryCount} after {duration}s");
            });
}

static IAsyncPolicy<HttpResponseMessage> GetTimeoutPolicy()
{
    return Policy.TimeoutAsync<HttpResponseMessage>(10); // 10秒超時
}
```

## BDD Test Validation

### 應該通過的場景
```gherkin
# ✅ 這些測試現在應該全部通過
Given 存在狀態為"Pending"的任務
And Callback API回應200 OK
When 我執行任務
Then 任務狀態應該更新為"Completed"
And Callback API應該被呼叫一次
And 任務應該被搬移到封存表

Given 存在狀態為"Pending"的任務
And Callback API回應500錯誤
When 我執行任務
Then 任務狀態應該更新為"Failed"
And 錯誤資訊應該被記錄
```

## Dependencies
- [ ] T006 - API控制器開發完成
- [ ] 了解 HTTP 客戶端最佳實踐
- [ ] Polly 重試策略概念

## Effort Estimate
- Size: L
- Hours: 14-18 小時
- Parallel: true (可與效能測試並行)

## Definition of Done
- [ ] ICallbackService 實作完成並通過單元測試
- [ ] HttpClient 與 Polly 整合正確設定
- [ ] 重試機制和錯誤處理完整實作
- [ ] **所有 BDD 測試場景通過 (綠燈狀態)**
- [ ] TaskService.ExecuteTaskAsync 包含完整 Callback 邏輯
- [ ] 同步和非同步 Callback 都測試通過
- [ ] 效能測試：Callback 處理時間符合預期
- [ ] 記錄和監控機制正常運作