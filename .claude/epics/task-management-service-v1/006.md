---
name: API控制器開發 (Red→Green)
status: open
created: 2025-09-13T13:20:32Z
updated: 2025-09-13T13:20:32Z
github: [Will be updated when synced to GitHub]
depends_on: [005]  # 需要儲存層實作完成
parallel: false  # 依序實作API層
conflicts_with: []
---

# Task: API控制器開發 (Red→Green)

## Description

實作 TasksController 的 6 個 RESTful API 端點，讓所有 API 相關的 Gherkin 測試場景從**紅燈轉為綠燈**。專注於讓測試通過的核心功能實作。

## BDD Context
**目標**: 讓以下 API 測試場景通過
- POST /api/v1/tasks (建立任務)
- POST /api/v1/tasks/{id}/dequeue (取出任務)
- POST /api/v1/tasks/{id}/execute (執行任務 - 不含Callback)
- GET /api/v1/tasks/{id} (查詢任務)
- DELETE /api/v1/tasks/{id} (取消任務)
- GET /api/v1/tasks (任務清單)

## Acceptance Criteria
- [ ] 實作 TasksController 的 6 個核心端點
- [ ] 實作 ITaskService 業務邏輯層
- [ ] 設置模型驗證和錯誤處理中間件
- [ ] 設定 Swagger/OpenAPI 文件
- [ ] **所有 API 相關的 BDD 測試通過 (除了 Callback)**
- [ ] API 回應格式符合 PRD 規格
- [ ] 錯誤處理符合 RESTful 標準

## Technical Details

### TasksController 實作
```csharp
// Controllers/TasksController.cs
[ApiController]
[Route("api/v1/[controller]")]
public class TasksController : ControllerBase
{
    private readonly ITaskService _taskService;

    public TasksController(ITaskService taskService)
    {
        _taskService = taskService;
    }

    [HttpPost]
    public async Task<ActionResult<TaskResponse>> CreateTask([FromBody] TaskCreateRequest request)
    {
        var result = await _taskService.CreateTaskAsync(request);

        if (!result.IsSuccess)
            return BadRequest(new { error = result.ErrorMessage });

        return CreatedAtAction(nameof(GetTask), new { id = result.Value!.TaskId }, result.Value);
    }

    [HttpPost("{id}/dequeue")]
    public async Task<ActionResult<TaskResponse>> DequeueTask(Guid id)
    {
        var result = await _taskService.DequeueTaskAsync(id);

        if (!result.IsSuccess)
            return NotFound(new { error = result.ErrorMessage });

        return Ok(result.Value);
    }

    [HttpPost("{id}/execute")]
    public async Task<ActionResult<TaskExecutionResponse>> ExecuteTask(Guid id)
    {
        var result = await _taskService.ExecuteTaskAsync(id);

        if (!result.IsSuccess)
            return BadRequest(new { error = result.ErrorMessage });

        return Ok(result.Value);
    }

    [HttpGet("{id}")]
    public async Task<ActionResult<TaskResponse>> GetTask(Guid id)
    {
        var result = await _taskService.GetTaskAsync(id);

        if (result.Value == null)
            return NotFound(new { error = "Task not found" });

        return Ok(result.Value);
    }

    [HttpDelete("{id}")]
    public async Task<IActionResult> CancelTask(Guid id)
    {
        var result = await _taskService.CancelTaskAsync(id);

        if (!result.IsSuccess)
            return BadRequest(new { error = result.ErrorMessage });

        return NoContent();
    }

    [HttpGet]
    public async Task<ActionResult<TaskListResponse>> GetTasks(
        [FromQuery] TaskStatus? status,
        [FromQuery] int page = 1,
        [FromQuery] int size = 10)
    {
        var result = await _taskService.GetTasksAsync(status, page, size);
        return Ok(result.Value);
    }
}
```

### ITaskService 介面和實作
```csharp
// Services/ITaskService.cs
public interface ITaskService
{
    Task<Result<TaskResponse>> CreateTaskAsync(TaskCreateRequest request);
    Task<Result<TaskResponse>> DequeueTaskAsync(Guid taskId);
    Task<Result<TaskExecutionResponse>> ExecuteTaskAsync(Guid taskId);
    Task<Result<TaskResponse?>> GetTaskAsync(Guid id);
    Task<Result> CancelTaskAsync(Guid id);
    Task<Result<TaskListResponse>> GetTasksAsync(TaskStatus? status, int page, int size);
}

// Services/TaskService.cs
public class TaskService : ITaskService
{
    private readonly ITaskRepository _repository;
    private readonly IQueueService _queueService;

    public TaskService(ITaskRepository repository, IQueueService queueService)
    {
        _repository = repository;
        _queueService = queueService;
    }

    public async Task<Result<TaskResponse>> CreateTaskAsync(TaskCreateRequest request)
    {
        var taskItem = new TaskItem
        {
            Id = Guid.NewGuid(),
            Name = request.Name,
            Description = request.Description,
            CallbackUrl = request.CallbackUrl,
            Status = TaskStatus.Queued,
            Payload = request.Payload,
            Priority = request.Priority,
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };

        var createResult = await _repository.CreateAsync(taskItem);
        if (!createResult.IsSuccess)
            return Result<TaskResponse>.Failure(createResult.ErrorMessage);

        var enqueueResult = await _queueService.EnqueueAsync(taskItem.Id);
        if (!enqueueResult.IsSuccess)
            return Result<TaskResponse>.Failure("Failed to enqueue task");

        return Result<TaskResponse>.Success(MapToResponse(taskItem));
    }

    // 其他方法實作...
}
```

### 錯誤處理中間件
```csharp
// Middleware/ErrorHandlingMiddleware.cs
public class ErrorHandlingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<ErrorHandlingMiddleware> _logger;

    public async Task InvokeAsync(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Unhandled exception occurred");
            await HandleExceptionAsync(context, ex);
        }
    }

    private static async Task HandleExceptionAsync(HttpContext context, Exception exception)
    {
        context.Response.ContentType = "application/json";
        context.Response.StatusCode = 500;

        var response = new
        {
            error = "An internal server error occurred",
            details = exception.Message
        };

        await context.Response.WriteAsync(JsonSerializer.Serialize(response));
    }
}
```

### 回應模型
```csharp
// Models/TaskExecutionResponse.cs
public record TaskExecutionResponse
{
    public Guid TaskId { get; init; }
    public TaskStatus Status { get; init; }
    public DateTime ExecutedAt { get; init; }
    public object? CallbackResult { get; init; }
}

// Models/TaskListResponse.cs
public record TaskListResponse
{
    public IEnumerable<TaskResponse> Tasks { get; init; } = [];
    public int TotalCount { get; init; }
    public int Page { get; init; }
    public int PageSize { get; init; }
}
```

### Swagger 配置
```csharp
// Program.cs
builder.Services.AddSwaggerGen(c =>
{
    c.SwaggerDoc("v1", new OpenApiInfo
    {
        Title = "Task Management API",
        Version = "v1",
        Description = "Queue-based task management service"
    });
});
```

## BDD Test Validation

### 應該通過的場景
```gherkin
# ✅ 這些測試應該變成綠燈
When 我發送POST請求到"/api/v1/tasks"
Then 回應狀態碼應該是201

When 我呼叫GET"/api/v1/tasks/{id}"
Then 應該回傳任務詳細資訊

When 我呼叫DELETE"/api/v1/tasks/{id}"
Then 回應狀態碼應該是204
```

### 暫時跳過的場景
```gherkin
# ⏸️ 這些測試會在 T007 (Callback) 時處理
And Callback API應該被呼叫一次  # 暫時跳過
```

## Dependencies
- [ ] T005 - Memory 儲存層實作完成
- [ ] 理解 RESTful API 設計原則

## Effort Estimate
- Size: L
- Hours: 12-16 小時
- Parallel: false (需要依賴儲存層)

## Definition of Done
- [ ] 所有 6 個 API 端點實作完成且可編譯
- [ ] ITaskService 業務邏輯層實作完成
- [ ] 模型驗證正確運作 (400 錯誤回應)
- [ ] Swagger UI 可以成功呼叫所有端點
- [ ] **BDD 測試：API 相關場景通過 (除 Callback)**
- [ ] 整合測試覆蓋所有端點的成功和失敗路徑
- [ ] API 回應格式符合 OpenAPI 規格
- [ ] 錯誤處理中間件正確攔截例外