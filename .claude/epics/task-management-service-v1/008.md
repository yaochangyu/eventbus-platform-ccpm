---
name: 效能驗證測試實作
status: open
created: 2025-09-13T13:20:32Z
updated: 2025-09-13T13:20:32Z
github: [Will be updated when synced to GitHub]
depends_on: [006, 007]  # 需要API和Callback完成
parallel: true  # 可與Callback並行開發
conflicts_with: []
---

# Task: 效能驗證測試實作

## Description

建立完整的效能測試套件，驗證系統是否達到 PRD 中定義的效能需求。確保系統可以同時處理 100 個任務，API 回應時間符合標準。

## Performance Requirements (來自PRD)
- **併發處理**: 同時處理 100 個任務無效能劣化
- **API 回應時間**: < 200ms (95th percentile)
- **記憶體使用**: 穩態記憶體 < 512MB，無記憶體洩漏
- **Queue 操作延遲**: < 10ms

## Acceptance Criteria
- [ ] 建立併發任務處理測試 (100 個併發任務)
- [ ] 建立 API 效能基準測試 (所有6個端點)
- [ ] 建立記憶體使用分析測試
- [ ] 建立 Queue 操作效能測試
- [ ] 建立 Callback 效能測試 (模擬外部API延遲)
- [ ] 建立負載測試報告生成
- [ ] **所有效能指標達到 PRD 要求**
- [ ] 設置效能回歸測試機制

## Technical Details

### 併發任務處理測試
```csharp
// Tests/PerformanceTests/ConcurrentTaskProcessingTests.cs
[Fact]
public async Task Should_Handle_100_Concurrent_Tasks_Without_Performance_Degradation()
{
    // Arrange
    const int taskCount = 100;
    var tasks = new List<Task<HttpResponseMessage>>();
    var stopwatch = Stopwatch.StartNew();

    // Act - 建立 100 個併發任務
    for (int i = 0; i < taskCount; i++)
    {
        var request = new TaskCreateRequest
        {
            Name = $"ConcurrentTask_{i}",
            Description = $"Performance test task {i}",
            CallbackUrl = "http://mock-callback.test/webhook"
        };

        tasks.Add(_httpClient.PostAsJsonAsync("/api/v1/tasks", request));
    }

    var responses = await Task.WhenAll(tasks);
    stopwatch.Stop();

    // Assert
    responses.Should().AllSatisfy(r => r.StatusCode.Should().Be(HttpStatusCode.Created));
    stopwatch.Elapsed.Should().BeLessThan(TimeSpan.FromSeconds(10)); // 10秒內完成
}

[Fact]
public async Task Should_Process_100_Tasks_Concurrently_Within_Time_Limit()
{
    // 測試併發執行任務的效能
    const int concurrentExecutions = 100;
    var executionTasks = new List<Task>();

    var stopwatch = Stopwatch.StartNew();

    for (int i = 0; i < concurrentExecutions; i++)
    {
        executionTasks.Add(ProcessSingleTaskAsync());
    }

    await Task.WhenAll(executionTasks);
    stopwatch.Stop();

    stopwatch.Elapsed.Should().BeLessThan(TimeSpan.FromSeconds(30)); // 30秒內處理完所有任務
}
```

### API 效能基準測試
```csharp
// Tests/PerformanceTests/ApiPerformanceTests.cs
[Theory]
[InlineData("POST", "/api/v1/tasks")]
[InlineData("GET", "/api/v1/tasks")]
[InlineData("GET", "/api/v1/tasks/{id}")]
public async Task API_Response_Time_Should_Be_Under_200ms_95th_Percentile(string method, string endpoint)
{
    // Arrange
    const int requestCount = 100;
    var responseTimes = new List<double>();

    // Act
    for (int i = 0; i < requestCount; i++)
    {
        var stopwatch = Stopwatch.StartNew();

        var response = method switch
        {
            "POST" => await _httpClient.PostAsJsonAsync(endpoint, CreateValidRequest()),
            "GET" when endpoint.Contains("{id}") => await _httpClient.GetAsync($"/api/v1/tasks/{_testTaskId}"),
            "GET" => await _httpClient.GetAsync(endpoint),
            _ => throw new ArgumentException($"Unsupported method: {method}")
        };

        stopwatch.Stop();
        responseTimes.Add(stopwatch.Elapsed.TotalMilliseconds);

        response.Should().HaveStatusCode(HttpStatusCode.OK);
    }

    // Assert - 95th percentile 應該小於 200ms
    var percentile95 = responseTimes.OrderBy(x => x).Skip((int)(requestCount * 0.95)).First();
    percentile95.Should().BeLessThan(200);

    // 額外驗證
    var averageResponseTime = responseTimes.Average();
    averageResponseTime.Should().BeLessThan(100); // 平均回應時間應更短
}
```

### 記憶體使用分析測試
```csharp
// Tests/PerformanceTests/MemoryUsageTests.cs
[Fact]
public async Task Should_Not_Have_Memory_Leaks_During_Extended_Operation()
{
    // Arrange
    var initialMemory = GC.GetTotalMemory(forceFullCollection: true);

    // Act - 模擬長時間運行
    for (int cycle = 0; cycle < 10; cycle++)
    {
        await CreateAndProcessMultipleTasks(50); // 每個週期處理50個任務

        // 強制垃圾回收
        GC.Collect();
        GC.WaitForPendingFinalizers();
        GC.Collect();
    }

    // Assert
    var finalMemory = GC.GetTotalMemory(forceFullCollection: true);
    var memoryIncrease = finalMemory - initialMemory;
    var memoryIncreaseInMB = memoryIncrease / (1024 * 1024);

    memoryIncreaseInMB.Should().BeLessThan(50); // 記憶體增長不超過 50MB
}

[Fact]
public async Task Steady_State_Memory_Should_Be_Under_512MB()
{
    // 運行一段時間後檢查穩態記憶體使用
    await RunSteadyStateWorkload();

    var steadyStateMemory = GC.GetTotalMemory(forceFullCollection: true);
    var memoryInMB = steadyStateMemory / (1024 * 1024);

    memoryInMB.Should().BeLessThan(512);
}
```

### Queue 操作效能測試
```csharp
// Tests/PerformanceTests/QueuePerformanceTests.cs
[Fact]
public async Task Queue_Operations_Should_Complete_Under_10ms()
{
    // Arrange
    var queueService = _serviceProvider.GetRequiredService<IQueueService>();
    var operationTimes = new List<double>();

    // Test Enqueue performance
    for (int i = 0; i < 1000; i++)
    {
        var taskId = Guid.NewGuid();
        var stopwatch = Stopwatch.StartNew();

        await queueService.EnqueueAsync(taskId);

        stopwatch.Stop();
        operationTimes.Add(stopwatch.Elapsed.TotalMilliseconds);
    }

    // Assert
    var averageEnqueueTime = operationTimes.Average();
    var maxEnqueueTime = operationTimes.Max();

    averageEnqueueTime.Should().BeLessThan(5); // 平均 5ms
    maxEnqueueTime.Should().BeLessThan(10);    // 最大 10ms
}
```

### Callback 效能測試
```csharp
// Tests/PerformanceTests/CallbackPerformanceTests.cs
[Fact]
public async Task Should_Handle_Multiple_Concurrent_Callbacks()
{
    // 測試併發 Callback 處理能力
    const int concurrentCallbacks = 50;
    var callbackTasks = new List<Task>();

    using var mockServer = StartMockCallbackServer();

    var stopwatch = Stopwatch.StartNew();

    for (int i = 0; i < concurrentCallbacks; i++)
    {
        callbackTasks.Add(ExecuteTaskWithCallbackAsync($"task_{i}"));
    }

    await Task.WhenAll(callbackTasks);
    stopwatch.Stop();

    // 50個併發 Callback 應在合理時間內完成
    stopwatch.Elapsed.Should().BeLessThan(TimeSpan.FromSeconds(15));
}
```

### 效能報告生成
```csharp
// Tests/PerformanceTests/PerformanceReportGenerator.cs
public class PerformanceReportGenerator
{
    public async Task GeneratePerformanceReport()
    {
        var report = new PerformanceReport
        {
            TestDate = DateTime.UtcNow,
            ConcurrentTaskLimit = await TestConcurrentTaskLimit(),
            ApiResponseTimes = await MeasureApiResponseTimes(),
            MemoryUsage = await MeasureMemoryUsage(),
            QueueOperationTimes = await MeasureQueuePerformance()
        };

        await SaveReportToFile(report);
        ValidateAgainstRequirements(report);
    }

    private void ValidateAgainstRequirements(PerformanceReport report)
    {
        var failures = new List<string>();

        if (report.ConcurrentTaskLimit < 100)
            failures.Add($"Concurrent task limit: {report.ConcurrentTaskLimit} < 100");

        if (report.ApiResponseTimes.Percentile95 >= 200)
            failures.Add($"API 95th percentile: {report.ApiResponseTimes.Percentile95}ms >= 200ms");

        if (report.MemoryUsage.SteadyStateMB >= 512)
            failures.Add($"Memory usage: {report.MemoryUsage.SteadyStateMB}MB >= 512MB");

        if (failures.Any())
        {
            throw new PerformanceRequirementException($"Performance requirements not met: {string.Join(", ", failures)}");
        }
    }
}
```

## Dependencies
- [ ] T006 - API控制器實作完成
- [ ] T007 - Callback機制實作完成 (如果需要測試Callback效能)
- [ ] 效能測試工具和框架理解

## Effort Estimate
- Size: M
- Hours: 12-16 小時
- Parallel: true (可與Callback開發並行)

## Definition of Done
- [ ] 所有效能測試實作完成且可執行
- [ ] 併發處理測試驗證 100 個任務處理能力
- [ ] API 效能測試驗證 95th percentile < 200ms
- [ ] 記憶體洩漏測試通過，穩態記憶體 < 512MB
- [ ] Queue 操作效能測試平均延遲 < 10ms
- [ ] 效能報告自動生成並驗證需求合規性
- [ ] **所有 PRD 效能需求得到驗證和確認**
- [ ] 效能回歸測試整合到 CI/CD 流程
- [ ] 效能基準資料建立供未來比較