---
name: Memory儲存層實作 (Red→Green)
status: open
created: 2025-09-13T13:20:32Z
updated: 2025-09-13T13:20:32Z
github: [Will be updated when synced to GitHub]
depends_on: [003, 004]  # 需要領域模型和Gherkin場景
parallel: false  # 實作階段的第一步
conflicts_with: []
---

# Task: Memory儲存層實作 (Red→Green)

## Description

實作記憶體儲存層，讓 Gherkin 場景中與資料存取相關的測試從**紅燈轉為綠燈**。這是 BDD 的 Red→Green 階段第一步，專注於讓測試通過的最簡實作。

## BDD Context
**目標**: 讓以下測試場景通過
- TaskCreation.feature: 任務建立和佇列存放
- TaskDequeue.feature: 從佇列取出任務並儲存
- TaskQuery.feature: 任務狀態查詢
- TaskCancellation.feature: 任務取消和狀態更新

## Acceptance Criteria
- [ ] 實作 InMemoryTaskRepository 讓儲存相關測試通過
- [ ] 實作 InMemoryQueueService 讓佇列相關測試通過
- [ ] 確保執行緒安全 (ConcurrentDictionary, ConcurrentQueue)
- [ ] 實作封存機制 (Completed 任務搬移)
- [ ] 所有 Repository 方法回傳 Result<T> pattern
- [ ] 依賴注入配置正確
- [ ] **所有相關 BDD 測試從 Red 轉為 Green**

## Technical Details

### InMemoryTaskRepository 實作
```csharp
// Infrastructure/Persistence/InMemoryTaskRepository.cs
public class InMemoryTaskRepository : ITaskRepository
{
    private readonly ConcurrentDictionary<Guid, TaskItem> _tasks = new();
    private readonly ConcurrentDictionary<Guid, ArchivedTask> _archivedTasks = new();

    public Task<Result<TaskItem>> CreateAsync(TaskItem task)
    {
        if (_tasks.TryAdd(task.Id, task))
            return Task.FromResult(Result<TaskItem>.Success(task));

        return Task.FromResult(Result<TaskItem>.Failure("Task already exists"));
    }

    public Task<Result<TaskItem?>> GetByIdAsync(Guid id)
    {
        var task = _tasks.TryGetValue(id, out var found) ? found : null;
        return Task.FromResult(Result<TaskItem?>.Success(task));
    }

    public Task<Result> UpdateAsync(TaskItem task)
    {
        _tasks.TryUpdate(task.Id, task, _tasks[task.Id]);

        // 自動封存 Completed 任務
        if (task.IsCompleted)
        {
            ArchiveTask(task);
        }

        return Task.FromResult(Result.Success());
    }

    private void ArchiveTask(TaskItem task)
    {
        var archived = new ArchivedTask
        {
            Id = task.Id,
            Name = task.Name,
            FinalStatus = task.Status,
            CompletedAt = task.ExecutedAt ?? DateTime.UtcNow,
            ArchivedAt = DateTime.UtcNow
        };

        _archivedTasks.TryAdd(task.Id, archived);
        _tasks.TryRemove(task.Id, out _);
    }
}
```

### InMemoryQueueService 實作
```csharp
// Infrastructure/Queue/InMemoryQueueService.cs
public class InMemoryQueueService : IQueueService
{
    private readonly ConcurrentQueue<Guid> _taskQueue = new();
    private readonly ConcurrentDictionary<Guid, bool> _enqueuedTasks = new();

    public Task<Result> EnqueueAsync(Guid taskId)
    {
        if (_enqueuedTasks.TryAdd(taskId, true))
        {
            _taskQueue.Enqueue(taskId);
            return Task.FromResult(Result.Success());
        }

        return Task.FromResult(Result.Failure("Task already in queue"));
    }

    public Task<Result<Guid?>> DequeueAsync()
    {
        if (_taskQueue.TryDequeue(out var taskId))
        {
            _enqueuedTasks.TryRemove(taskId, out _);
            return Task.FromResult(Result<Guid?>.Success(taskId));
        }

        return Task.FromResult(Result<Guid?>.Success(null));
    }

    public Task<Result> RemoveAsync(Guid taskId)
    {
        _enqueuedTasks.TryRemove(taskId, out _);
        return Task.FromResult(Result.Success());
    }

    public Task<int> GetCountAsync()
    {
        return Task.FromResult(_taskQueue.Count);
    }
}
```

### 依賴注入配置
```csharp
// Program.cs
builder.Services.AddSingleton<ITaskRepository, InMemoryTaskRepository>();
builder.Services.AddSingleton<IQueueService, InMemoryQueueService>();
```

### ArchivedTask 模型
```csharp
// Domain/Entities/ArchivedTask.cs
public class ArchivedTask
{
    public Guid Id { get; init; }
    public string Name { get; init; } = string.Empty;
    public TaskStatus FinalStatus { get; init; }
    public DateTime CompletedAt { get; init; }
    public DateTime ArchivedAt { get; init; }
    public object? CallbackResult { get; init; }
}
```

## BDD Test Validation
執行測試確認以下場景通過：

### 通過的場景範例
```gherkin
Given 我有有效的任務資訊
When 我發送POST請求到"/api/v1/tasks"
Then 任務應該被加入到Queue  # ✅ 應該通過

Given 存在狀態為"Pending"的任務
When 我查詢任務狀態
Then 應該回傳正確的任務資訊  # ✅ 應該通過
```

## Dependencies
- [ ] T003 - 領域模型設計完成
- [ ] T004 - Gherkin 場景撰寫完成
- [ ] 清楚理解哪些測試應該通過

## Effort Estimate
- Size: M
- Hours: 10-12 小時
- Parallel: false (BDD 實作第一步)

## Definition of Done
- [ ] InMemoryTaskRepository 所有方法實作完成
- [ ] InMemoryQueueService 所有方法實作完成
- [ ] 執行緒安全驗證通過 (併發測試)
- [ ] 封存機制正確運作
- [ ] **BDD 測試執行：儲存相關場景從 Red 變 Green**
- [ ] 單元測試覆蓋所有 Repository 方法
- [ ] 效能測試：100 併發任務處理無問題
- [ ] 記憶體洩漏檢查通過