---
name: 部署環境準備與DevOps整合
status: open
created: 2025-09-13T13:20:32Z
updated: 2025-09-13T13:20:32Z
github: [Will be updated when synced to GitHub]
depends_on: [001, 002, 003, 004, 005, 006, 007, 008]  # 需要所有前置任務完成
parallel: false  # 最終整合任務
conflicts_with: []
---

# Task: 部署環境準備與DevOps整合

## Description

建立完整的部署環境和 DevOps 整合，包含 Docker 容器化、健康檢查、監控整合和 CI/CD 流程。確保系統可以順利部署到生產環境並具備基本的維運能力。

## Acceptance Criteria
- [ ] Docker 容器化完成 (多階段建置優化)
- [ ] 健康檢查端點實作 (/health, /ready)
- [ ] Serilog 結構化日誌整合
- [ ] 基本 Metrics 收集 (Prometheus格式)
- [ ] Docker Compose 本地開發環境
- [ ] GitHub Actions CI/CD 流程
- [ ] 部署文件和運維指南
- [ ] **系統可以成功部署並正常運行**

## Technical Details

### Docker 容器化
```dockerfile
# Dockerfile (多階段建置)
FROM mcr.microsoft.com/dotnet/sdk:9.0 AS build
WORKDIR /src

# 複製專案檔案並還原套件
COPY ["src/TaskManagement.Api/TaskManagement.Api.csproj", "src/TaskManagement.Api/"]
RUN dotnet restore "src/TaskManagement.Api/TaskManagement.Api.csproj"

# 複製所有檔案並建置
COPY . .
WORKDIR "/src/src/TaskManagement.Api"
RUN dotnet build "TaskManagement.Api.csproj" -c Release -o /app/build

# 發佈階段
FROM build AS publish
RUN dotnet publish "TaskManagement.Api.csproj" -c Release -o /app/publish /p:UseAppHost=false

# 執行階段
FROM mcr.microsoft.com/dotnet/aspnet:9.0 AS final
WORKDIR /app

# 建立非 root 使用者
RUN addgroup --group --gid 1001 appgroup && \
    adduser --disabled-password --gecos "" --ingroup appgroup --uid 1001 appuser

# 複製應用程式
COPY --from=publish /app/publish .
RUN chown -R appuser:appgroup /app

# 切換到非 root 使用者
USER appuser

# 設置健康檢查
HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \
    CMD curl -f http://localhost:8080/health || exit 1

EXPOSE 8080
ENTRYPOINT ["dotnet", "TaskManagement.Api.dll"]
```

### 健康檢查實作
```csharp
// HealthChecks/TaskManagementHealthCheck.cs
public class TaskManagementHealthCheck : IHealthCheck
{
    private readonly ITaskRepository _repository;
    private readonly IQueueService _queueService;

    public TaskManagementHealthCheck(ITaskRepository repository, IQueueService queueService)
    {
        _repository = repository;
        _queueService = queueService;
    }

    public async Task<HealthCheckResult> CheckHealthAsync(HealthCheckContext context, CancellationToken cancellationToken = default)
    {
        try
        {
            // 檢查 Repository 是否正常
            var testTask = new TaskItem
            {
                Id = Guid.NewGuid(),
                Name = "HealthCheck",
                CallbackUrl = "http://test.com",
                Status = TaskStatus.Queued,
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow
            };

            var createResult = await _repository.CreateAsync(testTask);
            if (!createResult.IsSuccess)
                return HealthCheckResult.Unhealthy("Repository health check failed");

            // 檢查 Queue 是否正常
            var queueCount = await _queueService.GetCountAsync();

            // 清理測試資料
            await _repository.DeleteAsync(testTask.Id);

            return HealthCheckResult.Healthy($"Task management service is healthy. Queue count: {queueCount}");
        }
        catch (Exception ex)
        {
            return HealthCheckResult.Unhealthy($"Task management service is unhealthy: {ex.Message}");
        }
    }
}

// Program.cs 中的健康檢查設定
builder.Services.AddHealthChecks()
    .AddCheck<TaskManagementHealthCheck>("task-management")
    .AddCheck("self", () => HealthCheckResult.Healthy());

app.MapHealthChecks("/health", new HealthCheckOptions
{
    ResponseWriter = UIResponseWriter.WriteHealthCheckUIResponse
});

app.MapHealthChecks("/ready", new HealthCheckOptions
{
    Predicate = check => check.Tags.Contains("ready")
});
```

### Serilog 結構化日誌
```csharp
// Program.cs - Serilog 配置
builder.Host.UseSerilog((context, services, configuration) =>
{
    configuration
        .ReadFrom.Configuration(context.Configuration)
        .ReadFrom.Services(services)
        .Enrich.FromLogContext()
        .Enrich.WithMachineName()
        .Enrich.WithThreadId()
        .WriteTo.Console(new JsonFormatter())
        .WriteTo.File(
            path: "/app/logs/taskmanagement-.log",
            rollingInterval: RollingInterval.Day,
            formatter: new JsonFormatter(),
            retainedFileCountLimit: 7);
});

// appsettings.json
{
  "Serilog": {
    "MinimumLevel": {
      "Default": "Information",
      "Override": {
        "Microsoft": "Warning",
        "System": "Warning"
      }
    },
    "Properties": {
      "Application": "TaskManagement.Api"
    }
  }
}
```

### Metrics 收集 (Prometheus)
```csharp
// Metrics/TaskManagementMetrics.cs
public class TaskManagementMetrics
{
    private readonly Counter _tasksCreated = Metrics
        .CreateCounter("tasks_created_total", "Total number of tasks created");

    private readonly Counter _tasksCompleted = Metrics
        .CreateCounter("tasks_completed_total", "Total number of tasks completed");

    private readonly Counter _tasksFailed = Metrics
        .CreateCounter("tasks_failed_total", "Total number of tasks failed");

    private readonly Histogram _callbackDuration = Metrics
        .CreateHistogram("callback_duration_seconds", "Duration of callback executions");

    private readonly Gauge _queueSize = Metrics
        .CreateGauge("queue_size", "Current number of tasks in queue");

    public void RecordTaskCreated() => _tasksCreated.Inc();
    public void RecordTaskCompleted() => _tasksCompleted.Inc();
    public void RecordTaskFailed() => _tasksFailed.Inc();
    public void RecordCallbackDuration(double seconds) => _callbackDuration.Observe(seconds);
    public void SetQueueSize(int size) => _queueSize.Set(size);
}

// Program.cs
builder.Services.AddSingleton<TaskManagementMetrics>();
app.UseMetricServer(); // /metrics 端點
```

### Docker Compose 本地環境
```yaml
# docker-compose.yml
version: '3.8'

services:
  taskmanagement-api:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "8080:8080"
    environment:
      - ASPNETCORE_ENVIRONMENT=Development
      - ASPNETCORE_URLS=http://+:8080
    volumes:
      - ./logs:/app/logs
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    depends_on:
      - mock-callback

  mock-callback:
    image: wiremock/wiremock:latest
    ports:
      - "9999:8080"
    volumes:
      - ./test-data/wiremock:/home/wiremock
    command: ["--global-response-templating"]

  prometheus:
    image: prom/prometheus:latest
    ports:
      - "9090:9090"
    volumes:
      - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--web.console.libraries=/etc/prometheus/console_libraries'
      - '--web.console.templates=/etc/prometheus/consoles'
```

### GitHub Actions CI/CD
```yaml
# .github/workflows/ci-cd.yml
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '9.0.x'

    - name: Restore dependencies
      run: dotnet restore

    - name: Build
      run: dotnet build --no-restore

    - name: Unit Tests
      run: dotnet test tests/TaskManagement.UnitTests --no-build --verbosity normal --collect:"XPlat Code Coverage"

    - name: Integration Tests
      run: dotnet test tests/TaskManagement.IntegrationTests --no-build --verbosity normal

    - name: BDD Tests
      run: dotnet test tests/TaskManagement.AcceptanceTests --no-build --verbosity normal

  build-and-push:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
    - uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Login to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: |
          ghcr.io/${{ github.repository }}/taskmanagement-api:latest
          ghcr.io/${{ github.repository }}/taskmanagement-api:${{ github.sha }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
    - name: Deploy to staging
      run: |
        echo "Deploying to staging environment..."
        # 這裡可以加入實際的部署邏輯
```

### 部署文件
```markdown
# 部署指南

## 本地開發環境
1. 複製專案: `git clone <repository-url>`
2. 啟動服務: `docker-compose up -d`
3. 查看健康狀態: `curl http://localhost:8080/health`
4. 查看 Swagger: `http://localhost:8080/swagger`
5. 查看 Metrics: `http://localhost:8080/metrics`

## 生產環境部署
1. 建置 Docker 映像
2. 設定環境變數
3. 執行健康檢查
4. 監控 Metrics 和日誌

## 監控和維運
- 健康檢查: `/health`, `/ready`
- Metrics: `/metrics` (Prometheus 格式)
- 日誌: 結構化 JSON 格式，保留 7 天
- 錯誤追蹤: 透過結構化日誌
```

## Dependencies
- [ ] 所有前置任務 (T001-T008) 完成
- [ ] Docker 和容器化概念理解
- [ ] CI/CD 流程設計經驗
- [ ] 監控和維運最佳實踐

## Effort Estimate
- Size: L
- Hours: 14-18 小時
- Parallel: false (需要所有功能完成)

## Definition of Done
- [ ] Docker 映像可以成功建置並執行
- [ ] 健康檢查端點回應正確狀態
- [ ] Serilog 日誌正確輸出到檔案和控制台
- [ ] Prometheus metrics 可以正常收集
- [ ] Docker Compose 環境可以一鍵啟動
- [ ] GitHub Actions CI/CD 流程成功執行
- [ ] **系統可以部署到類生產環境並正常運行**
- [ ] 部署文件完整且可執行
- [ ] 監控和維運機制驗證正常